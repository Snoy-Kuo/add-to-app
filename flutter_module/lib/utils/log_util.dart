import 'dart:convert';

import 'package:logger/logger.dart';

class LogUtil {
  static String tag = 'RDTest';
  static int methodCount = 1;
  static int stackTraceBeginIndex = 0;

  static Logger logger = Logger(
    printer: SingleLinePrinter(
        tag: tag,
        stackTraceBeginIndex: stackTraceBeginIndex,
        methodCount: methodCount),
  );

  static d(dynamic message) {
    logger.d('$message');
  }
  static e(dynamic message) {
    logger.e('$message');
  }
}

class SingleLinePrinter extends LogPrinter {
  final String tag;
  final int methodCount;
  final int errorMethodCount;
  final int stackTraceBeginIndex;
  final bool printTime;
  final bool colors;
  final bool printEmojis;

  SingleLinePrinter({
    this.tag = 'RDTest',
    this.stackTraceBeginIndex = 0,
    this.methodCount = 1,
    this.errorMethodCount = 8,
    this.printTime = false,
    this.colors = true,
    this.printEmojis = true,
  });

  @override
  List<String> log(LogEvent event) {
    var messageStr = stringifyMessage(event.message);

    String? stackTraceStr;
    if (event.stackTrace == null) {
      if (methodCount > 0) {
        stackTraceStr = formatStackTrace(StackTrace.current, methodCount);
      }
    } else if (event.error == null){
      if (methodCount > 0) {
        stackTraceStr = formatStackTrace(event.stackTrace, methodCount);
      }
    } else if (event.error !=null && errorMethodCount > 0) {
      stackTraceStr = formatStackTrace(event.stackTrace, errorMethodCount);
    }

    var errorStr = event.error?.toString();

    String? timeStr;
    if (printTime) {
      timeStr = getTime();
    }

    return _formatAndPrint(
      event.level,
      messageStr,
      timeStr,
      errorStr,
      stackTraceStr,
    );
  }

  String stringifyMessage(dynamic message) {
    if (message is Map || message is Iterable) {
      var encoder = JsonEncoder.withIndent('  ');
      return encoder.convert(message);
    } else {
      return message.toString();
    }
  }

  String? formatStackTrace(StackTrace? stackTrace, int methodCount) {
    var lines = stackTrace.toString().split('\n');
    if (stackTraceBeginIndex > 0 && stackTraceBeginIndex < lines.length - 1) {
      lines = lines.sublist(stackTraceBeginIndex);
    }
    var formatted = <String>[];
    var count = 0;
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line) ||
          line.isEmpty) {
        continue;
      }
      String fixedLine = line.replaceFirst(RegExp(r'#\d+\s+'), '');
      int endPos = fixedLine.indexOf(' (');
      if (endPos < 0) endPos = fixedLine.length;
      formatted.add('[${fixedLine.substring(0, endPos)}]');

      if (++count == methodCount) {
        break;
      }
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join(' ');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    var match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(2)!.startsWith('package:logger') ||
        match.group(2)!.startsWith('package:flutter_module/utils/log_util.dart') ;
  }

  bool _discardWebStacktraceLine(String line) {
    var match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('packages/logger') ||
        match.group(1)!.startsWith('package:flutter_module/utils/log_util.dart') ||
        match.group(1)!.startsWith('dart-sdk/lib');
  }

  bool _discardBrowserStacktraceLine(String line) {
    var match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)!.startsWith('package:logger') ||
        match.group(1)!.startsWith('package:flutter_module/utils/log_util.dart') ||
        match.group(1)!.startsWith('dart:');
  }

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  final _deviceStackTraceRegex = RegExp(r'#[0-9]+[\s]+(.+) \(([^\s]+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)\/[^\s]+\/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/logger.dart
  final _browserStackTraceRegex = RegExp(r'^(?:package:)?(dart:[^\s]+|[^\s]+)');

  String getTime() {
    String _threeDigits(int n) {
      if (n >= 100) return '$n';
      if (n >= 10) return '0$n';
      return '00$n';
    }

    String _twoDigits(int n) {
      if (n >= 10) return '$n';
      return '0$n';
    }

    var now = DateTime.now();
    var h = _twoDigits(now.hour);
    var min = _twoDigits(now.minute);
    var sec = _twoDigits(now.second);
    var ms = _threeDigits(now.millisecond);
    return '$h:$min:$sec.$ms';
  }

  List<String> _formatAndPrint(
    Level level,
    String message,
    String? time,
    String? error,
    String? stacktrace,
  ) {
    // This code is non trivial and a type annotation here helps understanding.
    // ignore: omit_local_variable_types
    var color = _getLevelColor(level);
    var errorColor = _getErrorColor(level);
    var errorStr = error != null ? errorColor('[ERROR: $error]') : '';
    var timeStr = (time != null) ? '[$time]' : '';
    var emoji = _getEmoji(level);

    return [color('$emoji$timeStr[$tag]$stacktrace$message$errorStr')];
  }

  AnsiColor _getLevelColor(Level level) {
    if (colors) {
      return PrettyPrinter.levelColors[level]!;
    } else {
      return AnsiColor.none();
    }
  }

  AnsiColor _getErrorColor(Level level) {
    if (colors) {
      if (level == Level.wtf) {
        return PrettyPrinter.levelColors[Level.wtf]!.toBg();
      } else {
        return PrettyPrinter.levelColors[Level.error]!.toBg();
      }
    } else {
      return AnsiColor.none();
    }
  }

  String _getEmoji(Level level) {
    if (printEmojis) {
      return PrettyPrinter.levelEmojis[level]!;
    } else {
      return '';
    }
  }
}
